package scanner

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"os"
	"strings"
)

const HEADER_LENGTH = 64

var magicSequence = []byte{'P', 'A', 'R', '2', '\000', 'P', 'K', 'T'}

type Scanner struct {
	source   seekingReader
	filename string
	packet   Packet
	err      error
}

// NewScanner creates a new Scanner reading the given file.
func NewScanner(f *os.File) *Scanner {
	z := new(Scanner)
	z.reset(f)
	return z
}

type seekingReader interface {
	io.Reader
	io.Seeker
}

type packetHeader struct {
	packetLength  uint64
	md5Hash       [16]byte
	recoverySetId [16]byte
	packetType    [16]byte
}

func (s *Scanner) reset(f *os.File) {
	*s = Scanner{
		source:   f,
		filename: f.Name(),
		packet:   nil,
		err:      nil,
	}
}

func (s *Scanner) Scan() bool {
	magicSequenceBytes := make([]byte, 8)
	if _, err := io.ReadFull(s.source, magicSequenceBytes); err != nil {
		if err != io.EOF {
			s.err = fmt.Errorf("could not peek for magic sequence: %w", err)
		}
		return false
	}
	if bytes.Compare(magicSequenceBytes, magicSequence) != 0 {
		s.err = fmt.Errorf("could not find magic packet header in data")
		return false
	}

	header, err := readHeader(s.source)
	if err != nil {
		s.err = fmt.Errorf("could not read packet header: %w", err)
	}

	packetTypeString := string(header.packetType[:])
	if packetTypeString == mainPacketType {
		s.packet, s.err = scanMainPacket(s.source, header)
	} else if packetTypeString == fileDescriptionPacketType {
		s.packet, s.err = scanFileDescriptionPacket(s.source, header)
	} else if packetTypeString == fileSliceChecksumPacketType {
		s.packet, s.err = scanFileSliceChecksumPacket(s.source, header)
	} else if packetTypeString == recoverySlicePacketType {
		s.packet, s.err = scanRecoverySlicePacket(s.source, s.filename)
	} else if packetTypeString == creatorPacketType {
		s.packet, s.err = scanCreatorPacket(s.source, header)
	} else {
		s.packet = &unknownPacket{
			typ: packetTypeString,
		}
	}
	return true
}

// Err returns the first non-EOF error that was encountered by the scanner.
func (s *Scanner) Err() error {
	return s.err
}

// Packet returns the most recent packet generated by a call to Scan.
func (s *Scanner) Packet() Packet {
	return s.packet
}

func scanMainPacket(reader io.Reader, header packetHeader) (MainPacket, error) {
	var packet MainPacket

	sliceSize, err := readUint64(reader)
	if err != nil {
		err = fmt.Errorf("could not read slice size from main packet: %w", err)
		return packet, err
	}

	numRecoveryFiles, err := readUint32(reader)
	if err != nil {
		err = fmt.Errorf("could not read number of recovery files from main packet: %w", err)
		return packet, err
	}

	recoveryFileIDs := make([][16]byte, numRecoveryFiles)
	for i := uint32(0); i < numRecoveryFiles; i++ {
		if _, err = io.ReadFull(reader, recoveryFileIDs[i][:]); err != nil {
			return packet, fmt.Errorf("could not read recovery file ID %d from main packet: %w", i, err)
		}
	}

	// The number of non-recovery file IDs is the remaining space in the packet
	numNonRecoveryFiles := (header.packetLength - HEADER_LENGTH - 12 - 16*uint64(numRecoveryFiles)) / 16
	nonRecoveryFileIDs := make([][16]byte, numNonRecoveryFiles)
	for i := uint64(0); i < numNonRecoveryFiles; i++ {
		if _, err = io.ReadFull(reader, nonRecoveryFileIDs[i][:]); err != nil {
			return packet, fmt.Errorf("could not read non recovery file ID %d from main packet: %w", i, err)
		}
	}

	return MainPacket{
		SliceSize:          sliceSize,
		RecoveryFileIDs:    recoveryFileIDs,
		NonRecoveryFileIDs: nonRecoveryFileIDs,
	}, nil
}

func scanFileDescriptionPacket(reader io.Reader, header packetHeader) (packet FileDescriptionPacket, err error) {
	if _, err = io.ReadFull(reader, packet.ID[:]); err != nil {
		return packet, fmt.Errorf("could not read file ID from file description packet: %w", err)
	}
	if _, err = io.ReadFull(reader, packet.MD5[:]); err != nil {
		return packet, fmt.Errorf("could not read MD5 hash from file description packet: %w", err)
	}
	if _, err = io.ReadFull(reader, packet.MD516[:]); err != nil {
		return packet, fmt.Errorf("could not read MD5-16 from file description packet: %w", err)
	}
	packet.FileLength, err = readUint64(reader)
	if err != nil {
		err = fmt.Errorf("could not read file length from file description packet: %w", err)
		return packet, err
	}

	fileNameBytes := make([]byte, header.packetLength-HEADER_LENGTH-56)
	if _, err = io.ReadFull(reader, fileNameBytes); err != nil {
		err = fmt.Errorf("could not read file name bytes: %w", err)
		return
	}

	packet.FileName = strings.TrimRight(string(fileNameBytes[:]), "\000")
	return
}

func scanFileSliceChecksumPacket(reader io.Reader, header packetHeader) (packet FileSliceChecksumPacket, err error) {
	if _, err = io.ReadFull(reader, packet.FileID[:]); err != nil {
		return packet, fmt.Errorf("could not read file ID from file slice checksum packet: %w", err)
	}
	numSlices := (header.packetLength - 16 - HEADER_LENGTH) / 20
	packet.SliceHashes = make([][16]byte, numSlices)
	packet.SliceCRC32s = make([][4]byte, numSlices)

	for i := uint64(0); i < numSlices; i++ {
		if _, err = io.ReadFull(reader, packet.SliceHashes[i][:]); err != nil {
			return packet, fmt.Errorf("could not read hash %d from file slice checksum packet: %w", i, err)
		}
		if _, err = io.ReadFull(reader, packet.SliceCRC32s[i][:]); err != nil {
			return packet, fmt.Errorf("could not read CRC32 %d from file slice checksum packet: %w", i, err)
		}
	}

	return
}

func scanRecoverySlicePacket(source seekingReader, filePath string) (packet RecoverySlicePacket, err error) {
	if packet.Exponent, err = readUint32(source); err != nil {
		err = fmt.Errorf("could not read exponent from recovery slice packet: %w", err)
		return
	}
	currentOffset, err := source.Seek(0, io.SeekCurrent)
	if err != nil {
		err = fmt.Errorf("could not read current file position while parsing recovery slice packet: %w", err)
		return
	}
	packet.RecoveryDataFileOffset = uint32(currentOffset)
	packet.RecoveryDataFilePath = filePath

	return
}

func scanCreatorPacket(reader io.Reader, header packetHeader) (packet CreatorPacket, err error) {
	identifierBytes := make([]byte, header.packetLength-HEADER_LENGTH)
	if _, err = io.ReadFull(reader, identifierBytes); err != nil {
		err = fmt.Errorf("could not read creator packet identifier: %w", err)
		return
	}

	packet.Creator = strings.TrimRight(string(identifierBytes[:]), "\000")
	return
}

func readHeader(reader io.Reader) (header packetHeader, err error) {
	packetLengthBytes := make([]byte, 8)
	if _, err = io.ReadFull(reader, packetLengthBytes); err != nil {
		return
	}
	header.packetLength = binary.LittleEndian.Uint64(packetLengthBytes)

	if _, err = io.ReadFull(reader, header.md5Hash[:]); err != nil {
		err = fmt.Errorf("could not read md5 hash from packet header: %w", err)
		return
	}

	if _, err = io.ReadFull(reader, header.recoverySetId[:]); err != nil {
		err = fmt.Errorf("could not read recover set ID from packet header: %w", err)
		return
	}

	if _, err = io.ReadFull(reader, header.packetType[:]); err != nil {
		err = fmt.Errorf("could not read packet type from packet header: %w", err)
		return
	}

	return
}

func readUint32(reader io.Reader) (result uint32, err error) {
	bytes := make([]byte, 4)
	if _, err = io.ReadFull(reader, bytes); err != nil {
		err = fmt.Errorf("could not little endian number: %w", err)
		return
	}
	result = binary.LittleEndian.Uint32(bytes)
	return
}

func readUint64(reader io.Reader) (result uint64, err error) {
	bytes := make([]byte, 8)
	if _, err = io.ReadFull(reader, bytes); err != nil {
		err = fmt.Errorf("could not little endian number: %w", err)
		return
	}
	result = binary.LittleEndian.Uint64(bytes)
	return
}
